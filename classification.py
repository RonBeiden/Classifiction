# -*- coding: utf-8 -*-
"""206628505_207237314.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JKvJdmXrnTBYWAU8ZfWA8qeMq0vudb77
"""

import json
import os

# Installing the Kaggle package
!pip install kaggle 

!mkdir /root/.kaggle/ 

#Important Note: complete this with your own key - after running this for the first time remmember to **remove** your API_KEY
api_token = {"username":"","key":""}


# creating kaggle.json file with the personal API-Key details 
# You can also put this file on your Google Drive
with open('/root/.kaggle/kaggle.json', 'w') as file:
  json.dump(api_token, file)
!chmod 600 /root/.kaggle/kaggle.json

!mkdir ./datasets
!!mkdir ./datasets/Diamonds

!kaggle datasets download -d shivam2503/diamonds -p ./datasets/Diamonds
!chdir ./datasets/Diamonds
!unzip ./datasets/Diamonds/*.zip  -d ./datasets/Diamonds
!ls ./datasets/Diamonds

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import re 
import matplotlib
import matplotlib.pyplot as plt
from scipy.stats import pearsonr
import seaborn as sns
from sklearn.linear_model import LinearRegression
from numpy import  random
from sklearn.model_selection import train_test_split
from sklearn import metrics
from numpy import reshape
from sklearn.metrics import mean_squared_error
import plotly.express as px
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier 
from sklearn.model_selection import train_test_split 
from graphviz import Source
from sklearn import tree
# %matplotlib inline
df_Diamonds = pd.read_csv('/content/datasets/Diamonds/diamonds.csv',error_bad_lines=False)

"""# #**Diamonds**

#**Q1**
"""

train_df, test_df = train_test_split(df_Diamonds, test_size=0.2)
knn_classifier3 = KNeighborsClassifier(n_neighbors=3)
featues_list = ["table", "price", "depth", "carat", "x", "y"]
knn_classifier3.fit(train_df[featues_list], train_df["clarity"].values)
actual_clarity_list= test_df["clarity"].values
predict_clarity_list = knn_classifier3.predict(test_df[featues_list])
print("Accuracy: ", metrics.accuracy_score(actual_clarity_list, predict_clarity_list)) 
print("F1: ",  metrics.f1_score(actual_clarity_list, predict_clarity_list, average="weighted"))

"""#**Q2**"""

accuracy = []
f1 = []
for i in range(1,10,2):
    temp_classifier = KNeighborsClassifier(n_neighbors=i)
    temp_classifier.fit(train_df[featues_list], train_df["clarity"])
    actual_clarity_list= test_df["clarity"].values
    predict_clarity_list = temp_classifier.predict(test_df[featues_list])
    accuracy.append(metrics.accuracy_score(actual_clarity_list, predict_clarity_list))
    f1.append(metrics.f1_score(actual_clarity_list, predict_clarity_list, average="weighted"))
knn = [1,3,5,7,9]
graph1 = px.line(x=knn, y=accuracy)
graph2 = px.line(x=knn, y=f1)
graph1.update_layout(
    title="Accuracy/knn",
    xaxis_title="KNN",
    yaxis_title="ACCURACY")
graph2.update_layout(
    title="F1/knn",
    xaxis_title="KNN",
    yaxis_title="F1")
graph1.show()
graph2.show()

"""#**Q3**"""

accuracy_knn = []
knn_list = [1,3,5,7]
for i in knn_list:
    temp_classifier = KNeighborsClassifier(n_neighbors=i)
    temp_classifier.fit(train_df[featues_list], train_df["cut"])
    actual_cut_list= test_df["cut"].values
    predict_cut_list = temp_classifier.predict(test_df[featues_list])
    accuracy_knn.append(metrics.accuracy_score(actual_cut_list, predict_cut_list))
featues_list = ["table", "price", "depth", "carat", "x", "y"]
tree_cut = DecisionTreeClassifier()
tree_cut.fit(train_df[featues_list], train_df["cut"].values)
predict_cut_list = tree_cut.predict(test_df[featues_list])
accuracy_tree = metrics.accuracy_score(actual_cut_list, predict_cut_list)
if max(accuracy_knn) > accuracy_tree:
  print("Accuracy of knn:",max(accuracy_knn), "is better than decision tree:",accuracy_tree)
print("Accuracy of decision tree:",accuracy_tree ,"is better than knn:",max(accuracy_knn))

"""#**Q4**"""

from sklearn import preprocessing
accuracy_knn_new = []
clarity = set(train_df["clarity"].values)
color = set(train_df["color"].values)
le_clarity = preprocessing.LabelEncoder()
le_clarity.fit(list(clarity))
le_color = preprocessing.LabelEncoder()
le_color.fit(list(color))
clarity_numbers = le_clarity.transform(['I1', 'IF', 'SI1', 'SI2', 'VS1', 'VS2', 'VVS1', 'VVS2'])
clarity_num= le_clarity.transform(df_Diamonds["clarity"].values)
df_Diamonds["clarity numbers"] = clarity_num
color_numbers = le_color.transform(['D', 'E', 'F', 'G', 'H', 'I', 'J'])
color_num= le_color.transform(df_Diamonds["color"].values)
df_Diamonds["color numbers"] = color_num
train_df, test_df = train_test_split(df_Diamonds, test_size=0.2)
featues_list_8= ["price", "depth", "carat","y","x","table","color numbers","clarity numbers"] 
for i in knn_list:
    temp_classifier = KNeighborsClassifier(n_neighbors=i)
    temp_classifier.fit(train_df[featues_list_8], train_df["cut"])
    actual_cut_list= test_df["cut"].values
    predict_cut_list = temp_classifier.predict(test_df[featues_list_8])
    accuracy_knn_new.append(metrics.accuracy_score(actual_cut_list, predict_cut_list)) 
tree_cut = DecisionTreeClassifier()
tree_cut.fit(train_df[featues_list_8], train_df["cut"].values)
predict_cut_list = tree_cut.predict(test_df[featues_list_8])
accuracy_tree = metrics.accuracy_score(actual_cut_list, predict_cut_list)
print(accuracy_knn_new)
print(accuracy_tree)
print("The new accuracy of the new knn moudle didn't improve")

"""#**Q5**"""

accuracy_cut = []
size_list = [0.05,0.1,0.2,0.5,0.75,0.8,0.9]
for i in size_list:
  train_df, test_df = train_test_split(df_Diamonds, test_size=i)
  knn_classifier5 = KNeighborsClassifier(n_neighbors=5)
  featues_list = ["price", "depth", "carat","y","x","table","color numbers","clarity numbers"] 
  knn_classifier5.fit(train_df[featues_list], train_df["cut"].values)
  actual_cut_list= test_df["cut"].values
  predict_cut_list = knn_classifier5.predict(test_df[featues_list])
  accuracy_cut.append(metrics.accuracy_score(actual_cut_list, predict_cut_list))
accuracy_cut

fig = px.line(x=size_list, y=accuracy_cut, title="Trainset/Accuracy")
fig.update_xaxes(title_text = "Trainset")
fig.update_yaxes(title_text = "Accuracy")
fig.show()